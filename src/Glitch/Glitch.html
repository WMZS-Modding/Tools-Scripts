<!DOCTYPE html>
<html>
<head>
    <title>Flixel Glitch Shader - ZIP Export</title>
    <style>
        body { 
            margin: 0; 
            background: black; 
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            flex-direction: column;
        }
        canvas { 
            display: block; 
            max-width: 90vw; 
            max-height: 70vh;
            border: 1px solid #333;
        }
        .controls { 
            color: white; 
            background: rgba(0,0,0,0.7); 
            padding: 15px; 
            border-radius: 10px;
            margin: 10px;
            text-align: center;
        }
        button { 
            margin: 5px; 
            padding: 8px 15px; 
            background: #007acc;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        button:disabled {
            background: #555;
            cursor: not-allowed;
        }
        #status { 
            color: yellow; 
            margin-top: 10px;
            min-height: 20px;
        }
        input[type="range"] {
            width: 150px;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="controls">
        <input type="file" id="imageInput" accept="image/*" />
        <br><br>
        <button id="exportZipBtn">Export ZIP (60 Frames)</button>
        <div id="status">Ready to load image</div>
        <br>
        <div>Amount: <input type="range" id="amtSlider" min="0" max="1" step="0.1" value="0.5"></div>
        <div>Speed: <input type="range" id="speedSlider" min="0" max="2" step="0.1" value="1.0"></div>
        <div><label><input type="checkbox" id="invertCheck"> Invert Colors</label></div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2');
        const imageInput = document.getElementById('imageInput');
        const exportZipBtn = document.getElementById('exportZipBtn');
        const status = document.getElementById('status');

        canvas.width = 400;
        canvas.height = 300;

        if (!gl) {
            alert('WebGL 2 not supported! Try a different browser.');
        }

        const vertexShaderSource = `#version 300 es
            in vec2 aPosition;
            out vec2 vUv;
            void main() {
                vUv = aPosition * 0.5 + 0.5;
                gl_Position = vec4(aPosition, 0.0, 1.0);
            }
        `;

        const fragmentShaderSource = `#version 300 es
            precision highp float;
            
            uniform float iTime;
            uniform vec2 iResolution;
            uniform sampler2D iChannel0;
            uniform float AMT;
            uniform float SPEED;
            uniform int invert;
            
            in vec2 vUv;
            out vec4 fragColor;
            
            float random2d(vec2 n) { 
                return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);
            }

            float randomRange(in vec2 seed, in float min, in float max) {
                return min + random2d(seed) * (max - min);
            }

            float insideRange(float v, float bottom, float top) {
                return step(bottom, v) - step(top, v);
            }

            void main() {
                float time = floor(iTime * SPEED * 60.0);    
                vec2 uv = vUv;
                uv.y = 1.0 - uv.y;

                vec2 scale = vec2(1.0);
                float aspect = iResolution.x / iResolution.y;
                float imageAspect = iResolution.x / iResolution.y;
                
                if (aspect > imageAspect) {
                    scale.x = imageAspect / aspect;
                } else {
                    scale.y = aspect / imageAspect;
                }
                
                uv = (uv - 0.5) / scale + 0.5;

                if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
                    fragColor = vec4(0.0, 0.0, 0.0, 1.0);
                    return;
                }

                vec3 outCol = texture(iChannel0, uv).rgb;

                float maxOffset = AMT / 2.0;
                for (float i = 0.0; i < 10.0 * AMT; i += 1.0) {
                    float sliceY = random2d(vec2(time, 2345.0 + float(i)));
                    float sliceH = random2d(vec2(time, 9035.0 + float(i))) * 0.25;
                    float hOffset = randomRange(vec2(time, 9625.0 + float(i)), -maxOffset, maxOffset);
                    vec2 uvOff = uv;
                    uvOff.x += hOffset;
                    if (insideRange(uv.y, sliceY, fract(sliceY + sliceH)) == 1.0) {
                        outCol = texture(iChannel0, uvOff).rgb;
                    }
                }

                if (invert == 0) {
                    fragColor = vec4(outCol, 1.0);
                } else {
                    vec4 color = texture(iChannel0, uv);
                    fragColor = vec4(1.0 - color.rgb * outCol, 1.0);
                }
            }
        `;

        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        const aPosition = gl.getAttribLocation(program, 'aPosition');
        gl.enableVertexAttribArray(aPosition);
        gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);

        const iTimeLocation = gl.getUniformLocation(program, 'iTime');
        const iResolutionLocation = gl.getUniformLocation(program, 'iResolution');
        const iChannel0Location = gl.getUniformLocation(program, 'iChannel0');
        const AMTLocation = gl.getUniformLocation(program, 'AMT');
        const SPEEDLocation = gl.getUniformLocation(program, 'SPEED');
        const invertLocation = gl.getUniformLocation(program, 'invert');

        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([255, 0, 0, 255]));

        gl.uniform1f(AMTLocation, 0.5);
        gl.uniform1f(SPEEDLocation, 1.0);
        gl.uniform1i(invertLocation, 0);
        gl.uniform2f(iResolutionLocation, canvas.width, canvas.height);

        let currentImage = null;
        let isExporting = false;

        imageInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    currentImage = img;

                    const maxSize = 400;
                    let width = img.width;
                    let height = img.height;
                    
                    if (width > height && width > maxSize) {
                        height = (height / width) * maxSize;
                        width = maxSize;
                    } else if (height > maxSize) {
                        width = (width / height) * maxSize;
                        height = maxSize;
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    gl.viewport(0, 0, width, height);
                    
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    
                    gl.uniform2f(iResolutionLocation, width, height);
                    
                    status.textContent = 'Image loaded! Ready to export.';
                    status.style.color = 'lightgreen';
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        exportZipBtn.addEventListener('click', async function() {
            if (!currentImage) {
                alert('Please load an image first!');
                return;
            }

            if (isExporting) return;
            
            isExporting = true;
            exportZipBtn.disabled = true;
            status.textContent = 'Preparing frames...';
            status.style.color = 'yellow';
            
            const totalFrames = 60;
            const fps = 30;
            
            try {
                const zip = new JSZip();
                
                for (let frame = 0; frame < totalFrames; frame++) {
                    const currentTime = frame / fps;
                    gl.uniform1f(iTimeLocation, currentTime);
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                    const progress = Math.round((frame / totalFrames) * 100);
                    status.textContent = `Rendering frame ${frame + 1}/${totalFrames} (${progress}%)...`;

                    const blob = await new Promise(resolve => {
                        canvas.toBlob(resolve, 'image/png');
                    });
                    
                    const frameName = `glitch-frame-${String(frame).padStart(4, '0')}.png`;
                    zip.file(frameName, blob);

                    await new Promise(resolve => setTimeout(resolve, 10));
                }

                status.textContent = 'Creating ZIP file...';

                const zipBlob = await zip.generateAsync({type: 'blob'});

                const link = document.createElement('a');
                link.download = 'glitch-animation-frames.zip';
                link.href = URL.createObjectURL(zipBlob);
                link.click();
                URL.revokeObjectURL(link.href);
                
                status.textContent = `âœ“ Success! ${totalFrames} frames exported as ZIP`;
                status.style.color = 'lightgreen';
                
            } catch (error) {
                console.error('Export error:', error);
                status.textContent = 'Error exporting frames';
                status.style.color = 'red';
            } finally {
                exportZipBtn.disabled = false;
                isExporting = false;
            }
        });

        document.getElementById('amtSlider').addEventListener('input', e => {
            gl.uniform1f(AMTLocation, parseFloat(e.target.value));
        });

        document.getElementById('speedSlider').addEventListener('input', e => {
            gl.uniform1f(SPEEDLocation, parseFloat(e.target.value));
        });

        document.getElementById('invertCheck').addEventListener('change', e => {
            gl.uniform1i(invertLocation, e.target.checked ? 1 : 0);
        });

        function animate(time) {
            if (!isExporting && currentImage) {
                gl.uniform1f(iTimeLocation, time * 0.001);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            }
            requestAnimationFrame(animate);
        }
        animate(0);
    </script>
</body>
</html>